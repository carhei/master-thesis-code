
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\def\NoNumber#1{{\def\alglinenumber##1{}\State #1}\addtocounter{ALG@line}{-1}}
\def\hpi{\widehat{\pi}}
\def\hphi{\widehat{\phi}}
\def\M{{\mathbb M}}
\def\NN{{\mathbb N}}
\def\EE{{\mathbb E}}
\def\PP{{\mathbb P}}
\def\RR{{\mathbb R}}
\def\ind{{\mathbf{1}}}
\def\ore{\overrightarrow{e}}
\def\orE{\overrightarrow{E}}
\def\ole{\overleftarrow{e}}
\def\d{\partial}
\def\bx{\bold{x}}
\def\bw{\bold{w}}
\def\bB{\bold{B}}
\def\balpha{\bold{\alpha}}
\def\Poi{\text{Poi}}
\def\Bin{\text{Bin}}
\def\odeg{\overline{\text{deg}}}
\def\Acal{{\mathcal A}}
\def\Pcal{{\mathcal P}}
\def\Ocal{{\mathcal O}}
\def\Rcal{{\mathcal R}}
\def\Scal{{\mathcal S}}
\def\Dcal{{\mathcal D}}
\def\Qcal{{\mathcal Q}}
\def\Bcal{{\mathcal B}}
\def\Ical{{\mathcal I}}
\def\Hcal{{\mathcal H}}
\def\Ncal{{\mathcal N}}
\def\Mcal{{\mathcal M}}
\def\Lcal{{\mathcal L}}
\def\Gcal{{\mathcal G}}
\def\Xcal{{\mathcal X}}
\def\Ucal{{\mathcal U}}
\def\Vcal{{\mathcal V}}
\def\Zcal{{\mathcal Z}}
\def\BUT{{\mathcal{BUGWT}}}
\def\cGr{{{\mathcal G}_d}}
\def\Yb{\bold{Y}}
\def\bY{\bold{Y}}
\def\bI{\bold{I}}
\def\bZ{\bold{Z}}
\def\bW{\bold{W}}
\def\bM{\bold{M}}
\def\Xb{\bold{X}}
\def\bX{\bold{X}}
\def\omu{\overline{\mu}}
\def\oq{\overline{q}}
\def\bac{\backslash}
\def\kl{\mathrm{KL}}
\def\klber{\mathrm{kl}}
\def\supp{\mathrm{supp}}
\def\indic{\mathbbmss 1}
\def\alsp{\vspace{1mm}} 

\def\PF{\mathsf{pf}}
\def\algoM{\textsc{FairBand}}

\newcommand{\sk}{\nonumber\\}

\newcommand{\iskip}{{\vskip -0.4cm}}
\newcommand{\siskip}{{\vskip -0.2cm}}

\newcommand{\bp}{\noindent{\emph{Proof}.}\ }
\newcommand{\ep}{\hfill $\Box$}

\newcommand{\BEAS}{\begin{eqnarray*}}
\newcommand{\EEAS}{\end{eqnarray*}}
\newcommand{\BEA}{\begin{eqnarray}}
\newcommand{\EEA}{\end{eqnarray}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BNUM}{\begin{enumerate}}
\newcommand{\ENUM}{\end{enumerate}}
\newcommand{\argmin}{\arg\!\min}
\newcommand{\argmax}{\arg\!\max}


\begin{algorithm}[h!]
\small
   \caption{\textsc{Modification of Delayed Q-Learning}}
   \label{alg:alg1}
\begin{algorithmic}
   \REQUIRE $\Scal, \Acal,\gamma$, and $R_{\max}$, $m_0$, $\varepsilon_{\mathrm{target}}$. 
   \FORALL{$(s,a)$}
    \STATE $Q(s, a) \leftarrow R_{\max}/(1-\gamma)$ \qquad\qquad\qquad {\color{blue}  {\texttt{// optimistic initialization of $Q$-values}}} 
    \STATE $U_r(s,a) \leftarrow 0$   \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// empirical average reward of $(s,a)$}}} 
    \STATE $U_q(s,a) \leftarrow 0$   \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// per-batch cumulative $Q$-values for $(s,a)$}}} 
    \STATE $B(s, a) \leftarrow 0$   \qquad\qquad {\color{blue}  {\texttt{// beginning time-step of attempted update for $(s,a)$}}} 
    \STATE $C(s,a) \leftarrow 0$             \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// per-batch counter for $(s,a)$}}} 
    \STATE $N(s,a) \leftarrow 0$             \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// counter for $(s,a)$}}}
    \STATE $M(s, a) \leftarrow m_0$          \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// batch size for $(s,a)$}}}  
    \STATE $L(s,a)\leftarrow \textsf{TRUE} $  \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// the learning flag}}} 
   \ENDFOR
   \STATE $t_{\textrm{update}} \leftarrow 0$  \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// time-step of the most recent $Q$-value change}}}
   \STATE $\varepsilon \leftarrow 10^{-4}$     \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// threshold for admitting $Q$-value updates}}}
   
   \FOR{$t\geq 1$}   %\qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// main loop}}}
    \STATE Observe the current state $s_t$. Take action $a_t \in \argmax_{a\in \Acal} Q(s_t, a)$, receive reward $r_t$, and go to a next state $s_{t+1}$.    \alsp
    \IF{$B(s_t,a_t)\le t_{\textrm{update}}$} \alsp
        \STATE $L(s_t,a_t) \leftarrow \textsf{TRUE}$ \alsp
    \ENDIF
    
    \IF{$L(s_t,a_t)$=\textsf{TRUE}} \alsp
        \IF{$C(s_t,a_t)=0$} \alsp
            \STATE $B(s_t,a_t)\leftarrow t$ \alsp
        \ENDIF
        \STATE $C(s_t,a_t) \leftarrow C(s_t,a_t) + 1$ \alsp
        \STATE $U_r(s_t,a_t) \leftarrow \dfrac{U_r(s_t, a_t)N(s_t,a_t) + r_t}{N(s_t, a_t)+1}$ \alsp
        \STATE $N(s_t, a_t) \leftarrow N(s_t, a_t) + 1$ \alsp
        \STATE $U_q(s_t, a_t) \leftarrow U_q(s_t, a_t) + \gamma \max_{a\in \Acal} Q(s_{t+1}, a)$   \alsp
        \IF{$C(s_t,a_t)=M(s_t,a_t)$} \alsp
            \STATE $q \leftarrow U_r(s_t, a_t) + U_q(s_t, a_t)/M(s_t,a_t)$ \alsp
            \IF{$|Q(s_t,a_t)-q|\ge \varepsilon$} \alsp
                \STATE $Q(s_t,a_t) \leftarrow q$ \alsp  \qquad\qquad {\color{blue}  {\texttt{// update if $Q$-value changes significantly }}}
                \STATE $t_{\textrm{update}} \leftarrow t$ \alsp
            \ELSIF{$B(s_t,a_t)>t_{\textrm{update}}$} \alsp
                \STATE $L(s_t,a_t) \leftarrow \textsf{FALSE}$ \alsp
            \ENDIF
            \STATE $U_q(s_t,a_t) \leftarrow 0$ \alsp
            \STATE $C(s_t, a_t) \leftarrow 0$ \alsp
            \STATE $M(s_t, a_t) \leftarrow \min\{\lceil 1.02M(s_t,a_t)\rceil +1, 500\}$ \alsp  \qquad\qquad {\color{blue}  {\texttt{// increase batch size}}}
            \STATE $\varepsilon \leftarrow \min \{1.1\varepsilon_1, \varepsilon_{\mathrm{target}}\}$ \alsp  \qquad\qquad\qquad\qquad {\color{blue}  {\texttt{// increase the threshold}}}
        \ENDIF
    \ENDIF
   \ENDFOR             

\end{algorithmic}
\end{algorithm}

